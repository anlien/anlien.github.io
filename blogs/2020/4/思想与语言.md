之前听说过方法论，对问题的分解与解决问题都是有一定方法的。后来编程，写的程序大多是调用方法，而且喜欢将方法的功能单一化，例如做加、减、乘、除等各一个方法。

之前喜欢尝试，看见别人的代码，总觉得代码过于复杂，有些地方可以这样或那样。可尝试多了，回头看自己的代码，发现也出现了一些套路。代码的组织与结构体有些相似。

当回头看自己的代码，并回忆当时的想法时，有时觉得不好，有时觉得可笑。问题的本质没变，自己的应对却在变化着。

当回头翻些书籍时，之前会觉得写得不够细，现在会觉得大致轮廓清楚就好。因为代码的细节是不记得。思想是武器，设计是路子，编码只是实现。如果清楚系统的边界，做好功能划分与设计，一个好的系统就有了雏形。想象以下，若一个建筑工程没有设计图，没有功能分区，那建成是不可想象的。

# 局限性

公司需要某些系统来解决某些问题，例如物流管理、广告管理、运营等。在开发这些系统时，好的功能组合与划分就是系统设计。通常系统比较小（7、8个大的页面），难度一般。开发过广告系统来为公司创收，一月将近几百万的收入，但这关键确是得有一个好的广告总监。

之前的想象中的系统是有几百个人开发，和支持几百万人的访问。但现实确是，公司通常没有那么大的流量。当公司遇到访问量激增时，云端服务器会自动增加服务器，增加分布式。所以开发的系统是可以支持大量访问的，当然前提是需要设计好，例如设计缓存、cdn等。若有很严重的性能问题，可以使用客户端渲染（服务端到客户端还需要渲染），服务器只发资源。

虽然写的系统，通常只是1~4人同时开发，任务划分时也是按照功能模块划分，一个人做一个模块，共用的被提为工具方法。开发时，功能模块内的划分就靠个人了，没那么多的要求。这样说的话，其实个人只是负责一个功能模块。例如，常见的活动、主页、详情页、列表页、高筛页等，通常一个页面是一个功能模块，而系统正式由这些页面组成的。后端就是接口组成，外加一些管理设置。

计算机的出现得益于一个个问题得到解决，计算机出现那会是没有操作系统。图灵机是为了证明数学题的解。系统只是为了解决问题，而不是创造一项技术。C、C++、Java、nodejs等，只是与计算机交流的语言，开发出的系统，通常只是一个app应用。dos不也是一个app应用？

若计算机系统是解决人与机器的交互，那么在系统上开发的系统，不也是为了方便用户的操作。例如，前端就是在浏览器中运行的一段代码，解决的是用户交互的问题。

语言开发的功能模块，只是在某个系统上运行的代码，依赖于系统。

# 定位

梦想着仗技走天涯，看一看世界的繁华。现在回头看，发现技术只是组织的一部分，来解决组织的协作、管理等工作。之前觉得技术就是"渠"，公司用这些渠道来获得客户，将客户转化为资源，简单看就是用渠运资源。

设计好的系统，其实不在在乎谁实现，只要满足测试，就可以上线运行的。代码的好赖也许只有做开发的人员注重。但，一个系统维护2~5年或需求有大的改动，通常会选择重写（即便是原班人马），上线只是时间与资源的协调问题。

好的系统设计会将问题进行拆分，进行模块化、接口化等。若反向来看，实现后的系统很多是对接好接口、实现好某些功能，换个人只是换了实现方法（例如将加法换成乘法）。若细说，这中间肯定会有很多可以说道的，但抛去代码的好坏，功能的实现才是最重要的。但别忘了，语言只是媒介，实现功能时要使用系统的api。

若公司进行战略调整，很多项目可能被终止或者停止维护。一个公司兼并另一个公司，通常会将业务重写写一遍。

# 抽象

> * 程序 = 算法 + 数据结构
> * 软件 = 程序 + 软件工程
> * 软件公司 = 软件 + 商业模式
> * 往往软件工程的质量直接决定软件的质量，商业模式的优劣决定了一个公司的成败

软件的质量决定 **研发** 的成本。研发为了少加班，通常也会提高质量。

遇到过一个系统性能问题，性能的原因与开发人员写的代码无关，与系统打包的方式有关。

# 趋势

app是一个产品，为了方便 公司为 用户提供服务。app是了解决如何让用户方便使用公司服务的问题。发展的趋势都是为了 简化与方便。