
### 参考：
水母：http://aleksandarrodic.com/p/jellyfish/

javascript的计算能力因为google的V8引擎得到了迅猛的增强，做3D程序，做服务器都没有问题。如果你对服务器感兴趣，你可以看看nodejs
例子中的各个文档：

* Build目录：包含两个文件，three.js 和three.min.js 。这是three.js最终被引用的文件。一个已经压缩，一个没有压缩的js文件。
* Docs目录：这里是three.js的帮助文档，里面是各个函数的api，可惜并没有详细的解释。试图用这些文档来学会three.js是不可能的。
* Editor目录：一个类似3D-max的简单编辑程序，它能创建一些三维物体。
* Examples目录：一些很有趣的例子demo，可惜没有文档介绍。对图像学理解不深入的同学，学习成本非常高。
* Src目录：源代码目录，里面是所有源代码。
* Test目录：一些测试代码，基本没用。
* Utils目录：存放一些脚本，python文件的工具目录。例如将3D-Max格式的模型转换为three.js特有的json模型。
* .gitignore文件：git工具的过滤规则文件，没有用。
* CONTRIBUTING.md文件：一个怎么报bug，怎么获得帮助的说明文档。
* LICENSE文件：版权信息。
* README.md文件：介绍three.js的一个文件，里面还包含了各个版本的更新内容列表。

#### 一些定义
3D世界的组成
在计算机世界里，3D世界是由点组成，两个点能够组成一条直线，三个不在一条直线上的点就能够组成一个三角形面，无数三角形面就能够组成各种形状的物体。通常把这种网格模型叫做Mesh模型。给物体贴上皮肤，或者专业点就叫做纹理，那么这个物体就活灵活现了。最后无数的物体就组成了我们的3D世界。
在Threejs中定义一个点
在三维空间中的某一个点可以用一个坐标点来表示。一个坐标点由x,y,z三个分量构成。空间几何中，点可以用一个向量来表示，在Three.js中也是用一个向量来表示的。
THREE.Vector3 = function ( x, y, z ) {this.x = x || 0;this.y = y || 0;this.z = z || 0;};
点的操作
在3D世界中点可以用THREE.Vector3D来表示。
网格
网格：网格是由一个活多个多边形组成的物体，各个顶点的坐标（x,y,z）定义了多边形在3D空间中的位置。网格中的多边形通常都是三角形（包含三个顶点）和四边形（包含四个顶点）。3D网格通常也被叫做模型（model）。网格中各个顶点的x,y,z的坐标分量只是用于定义形状；而网格表面的其他特性，如颜色和着色，都是由除了顶点坐标（x,y,z）坐标之外的属性来定义的。
在大多数的图形系统中，网格表面的特性被统称为材质。材质通常依赖于一个活多个光源来呈现出外观效果。
网格可以包含若干个参数，例如基色、透明度和反光度。

部分不太清除的概念
材质中还可以包含一个或多个纹理，用位图的方式来覆盖网格表面。
Three.js内置了将2D纹理的具体位置（也就是所谓的纹理坐标、Uv坐标）印射到3D球体网格的各个顶点位置的算法。
THREE.MeshBasicMaterial是一种完全没有任何着色效果的材质。这种材质类型只是简单的将纹理的每个像素平铺到球体表面，如果纹理在某个像素上没有提供映射，那么它将使用材质本身的颜色值。


 Mesh就是一个网格表面，它代表着我们渲染到3D世界中的各种模型。其构造函数如下：THREE.Mesh = function ( geometry, material )。它接受2个参数，一个是几何体，一个是材质。
定义了纹理之后，我们将texture.needsUpdate设置为了true，如果不设置为true，那么纹理就不会更新，很可能你看到的是一个黑色的正方体，原因是纹理没有被载入之前，就开始渲染了，而渲染使用了默认的材质颜色。
这是什么原因呢？是这样的，纹理的绘制是需要一段时间的，javascript是可以异步运行的，在canvas绘制出时钟之前，可能three.js就开始根据纹理渲染图形了。如果纹理不更新，那么正方体一直会是以前没有绘制完成的纹理，很可能是材质本身的颜色。
另一个方面，canvas由于绘制的是时钟，其每一秒都会重新绘制一次，所以为了让正方体上的纹理可以及时反映canvas上的时钟，也需要不断的更新纹理，所以需要将needUpdate设置为true，不过缺点是其效率会低一些，不过这种效率的降低，是完全可以接受的。

WebGL本身并不直接支持光源和材质；所有的所谓的材质属性都是执行了一个或多个着色器的结果。

9-18   16
获取模型群组的各个部分的权限，这样才能让模型动起来。
Three.js的工具函数THREE.SceneUtils.traverseHierarchy()允许遍历整个物体的层级以便找到哪些部分是我们需要的。
为什么要定义着色器？
	为了在最终的图像中渲染模型，开发这必须精确的定义顶点、变换、材质、光源与相机之间的关系和交互。着色器是一小段程序代码，其中包含了将模型投射到屏幕上的像素算法。
	编写WebGL程序时，必须定义着色器，否则图形是不会显示在屏幕上的。WebGL的实现假定客户端电脑上配备有GPU。GPU可以处理顶点、纹理和其他一点东西，但它对材质、光源和变换却一无所知。把后者这些较高级的信息传递给GPU并最终把它们绘制到屏幕上的转换过程是由着色器来完成的，着色器是由开发者创建的。
	着色器赋予图形开发这完全的能力去操控每一个顶点和像素。


着色器
WebGl入门书上的解释：着色器给予图形开发者完全的能力去操控每一个顶点和像素。着色器是由两部分组成的：顶点着色器和片着色器，后者也被称为像素着色器。顶点着色器负责将物体的坐标转换到2D空间；片着色器负责生成最后的颜色输出到每个转换后的顶点像素，而颜色的输入则可以是纯色、纹理、光源或则材质。
Three.ParticleBasicMaterial.这个对象用于定义粒子系统的点的尺寸和颜色；
Three.LineBasicMaterial.可以指定线条的厚度、颜色和透明度。
着色器把原始的网络的顶点数据、点和线转换成最终显示在屏幕上的像素。


一个着色器实际上是由两段程序组成的：一个顶点着色器和一个片着色器。顶点着色器，是用于处理顶点的。它会处理用户传入的顶点在3D空间中的坐标位置，并转换成在2D显示屏上的像素的位置。一旦2D的为位置计算出来了，片着色器就会启动并计算该像素的颜色值，包括用于透明效果的alpha值。注意：顶点着色器和片着色器是结对按顺序执行的，对于绘制基元中的每一个得到都是如此。
着色器程序可以接收若干种不同的参数作为输入，顶点着色器还可以输入一些参数并传递到片着色器中。
着色器参数：
attribute：一个顶点的摸个属性，比如位置、法线向量和颜色，存储于该绘制基元所绑定的顶点缓存区中（vertex  buffer）。
varying:顶点着色器输出的一种参数，因顶点不同而异，可以用于传递给片元着色器。
uniform：对于每个顶点都是相同的一种常量。
Antialias:值为bool类型，true时是告诉Three启用抗锯齿渲染。抗锯齿可以避免绘制物体边缘时产生锯齿。

一些语句：
Buffer是什么？
WebGL的绘制是由图元组成的，图元的种类包括三角形（三角形数组）、三角形带、点和线。图元使用的数组被称为Buffer，它定义了顶点的位置。
Float32Array是什么数据类型？
Float32Array的数据类型，这是一种为了WebGl而专门引入浏览器中的新数据类型，是ArrayBuffer的一种，也被称为类型化数组，用于在javascript中存储二进制数据。在javascript中访问类型化数组可以使用与传统数据数组相同的语法，但是速度更快并且占用更少的内存。
纹理映射？
	纹理映射也被称为纹理，是一种将位图覆盖到3D网格表面的技术。使用纹理映射可以通过简单的方式定义网格表面的颜色，同时也可以通过纹理图片的组合应用创造出更加复杂的效果，如凹凸效果和高光效果。


光源的差异？
环境光：无论在任何位置都会照亮整个场景的常态光源。
点光源：从一个特定的点向周围所有方向照射光线的光源，光源受距离限制。
聚光灯：从一个特定的点向一个特定的方向照射光线的光源，光照受距离限制。
平行光：一种向一个特定的方向照射光线的光源，但是不受光照距离限制，并且与光源位置无关。


THREE.ShaderMaterial材质？
THREE.ShaderMaterial材质是Three.js为通用目的提供的材质类型。这种材质允许开发者自定义一段着色器代码，而不仅仅是配置几个固定的参数。实际上只要使用Three.js内置库，内置库中包括了一些常用的视觉效果。
THREE.MeshLambertMaterial材质？
Lambert着色法中，无论观察者观察的角度如何变化，物体表面上的明亮程度都是一样的。
应用过THREE.js内置库的库有哪些？
THREE.ShaderUtils这个是内置的着色器程序。法线贴图着色器：THREE.ShaderUtils.lib[‘normar’]。法线贴图的着色器程序需要至少一张法线贴图纹理来计算凹凸值。
切线是用于计算法线贴图值时必须的向量值。默认情况下，Three.js不会为几何体计算切线。
3D变换层级？
3D换层级通常只使用与父级对象相关的位置，利用这个特性我们可以开发出很多高级功能。。
常用的贴图有哪些？
	颜色贴图：提供了最基本的像素颜色。	
	法线贴图：法线贴图本质上是将一种额外的网格属性—也就是法线—编码成RGB值存储在一张位图文件中。法线决定了光照到网格表面时的亮度。更亮或更暗的区域依赖于法线值。相对于定义额外的顶点属性，法线可以以较高性能和更小资源消耗的方式实现网格表面崎岖不平的效果。通过将高度数据编码到法线贴图当中，我们可以只在网格中存储顶点数据，改善渲染性能。
	高光贴图：镜面高光或镜面反射是指网格表面的反光程度和反光量。和法线贴图类似，高光贴图也是一种高效的数据存储方式。较亮的RGB值表示反光度高的区域，较暗的RGB值表示反光度低的区域。
THREE.Object3D对象
	这个对象是Three.js对象的基类，包括网格、光源和相机。THREE.Object3D包括位置、朝向和缩放属性，用于操控这些对象；另外，它还有一些子类，当其他Three.js对象需要相对于它移动、缩放或是围绕它旋转的时候，可以更改这些属性值。
	从底层上说，这些属性（位置、旋转和缩放）在内部被转换成矩阵，用于在渲染时计算顶点在屏幕空间中的位置。对于Object3D对象的任意子类，其矩阵都会与父级矩阵相乘，然后不断往上，知道最顶层。所以，在Three.js中，无论你如何移动、旋转或缩放一个物体，它的子类也将一起移动、旋转和缩放。
UV是什么？
	UV坐标定义了文理图片的每个像素如何映射到网格表面。UV坐标的取值范围通常是0到1，U轴代表水平方向，向右递增；V轴代表垂直方向，向上递增。
	Uv相关的函数，暂时不太清楚。函数分别是：
	computeCentroids()函数；
boundingSphere来提供一些用于拾取和裁剪所需的数据；
computeFaceNormals()。


粒子系统是什么？
粒子系统是由一系列的点来描述的，Three.js的矢量对象定义了点在空间中的位置和材质。材质定义了颜色、所绘制的点的尺寸和其他一些可选的参数，比如纹理映射。
Three.js通过内置的ParticleSystem对象来提供对WebGl点的渲染支持。粒子系统是一个相当大的格局，可以用于创造出诸如火焰、爆炸、降雨、落雪和狂欢时抛洒的缤纷纸屑等效果。
ParticleBasicMaterial中sizeAttenuation参数为false时是告诉Three.js在夏季移动时不必重新缩放没个粒子。


第四章 动画
什么是帧动画？
	按每秒速固定速率、按顺序连续播放独立帧的动画技术。
	缺点：速率是固定的，不能充分发挥客户端电脑的性能。
什么是时间动画？
一系列的矢量图都与某个时间关联，而帧率则不固定。
矢量图和位图的差别？
	矢量图形则是由查询调用绘制库并使用像线和多边形这种图形基元来绘制。
补间动画
补间动画实际上是生成一对矢量值的中间值的过程。在补间动画中，动画生成器不需要为每一帧提供图形的矢量值；而是每隔0.5秒或在预定位置提供这些值，这被称为关键帧，电脑会负责生成中间值。
基于位图的补间动画是技术是存在的，但是它受拘束与两幅图片的各种因素，比如两者的变形效果，因此其使用范围非常有限。
补间动画使用了一种叫插值的数学技巧。插值是指已知两个值然后根据一个标量（例如时间或某个分量值）生成一个中间值。在3D动画中，插值用于计算3D空间中的位置、旋转、颜色、各种标量和其他属性的中间值。
关键帧动画
	关键帧动画这个术语是同时适用于帧动画和时间动画的。
关键帧动画中包含了一系列值，每个连续的值之间可以有不同的持续时间。关键帧动画中，既可以使用线性插值，也可以使用更复杂的插值算法。作为关键帧的数据点可以看做插值方程中的一条线，或者是更复杂的样条插值中的三次样条曲线。


关节动画
	通过构建层级让各自独立的局部分别运动最终组成整体动画的技术。关节动画被称为万能工具。
蒙皮动画||单一网格动画
	蒙皮动画专注于对网格顶点的变形，也就是所谓的蒙皮。
骨骼是为我们用来制作动画效果的一个理论对象。
通过改变骨骼属性，并设定好骨骼是如何改变蒙皮的，两者这起来就形成了蒙皮动画。
目标变形动画（变形）
	变形技术主要是通过网络顶点的插值计算来实现变形动画效果。通常人们会先将网格顶点的一个子集连同其索引存储起来，作为变形目标，用于生产补间动画。补间动画会对变形目标中的顶点值进行插值，然后动画系统会使用插值之后的顶点值改变网格顶点属性。变形的目标对于面部表情变化和其他使用蒙皮动画很难表现的细微效果来说非常实用：这样就无需再构造拥有无数面部骨头的高精度骨骼模型。这种技术是从顶点层面来控制网格的。

Tween.js
	Tween.js实际上是让把所有的动画效果串联起来形成一个队列。这样就可以把各自独立的动画效果组合起来形成一个非常复杂的整体效果。
	可以产生惯性和动量以及其他真实生活中的物理特质。
材质和光源动画
	制作材质和光源动画的基本原理：改变材质的透明度或颜色，或光源的强度或颜色，就会及时产生相应的动画效果。在WebGL中，材质动画是一项非常简单但又威力无比的武器。
	光源动画：改变光源强度、光源颜色和距离属性。光源是为场景增添氛围和渲染气氛的好方法。
纹理动画
	纹理变换：通过变换纹理的位置或缩放来实现的动画效果。
	使用纹理变换我们可以把纹理像素在x轴或y轴上进行位移，同时还可以进行放大或缩小的操作。把这种技术和关键帧动画结合在一起就可以创造出一些简单而又惊奇的效果。
	变换纹理也就是变换纹理的UV坐标位置。
	THREE.Texture有一个offset属性，其中定义了施加给纹理UV坐标的2D位置变换。Offset是一个2D矢量，拥有x和y坐标。在大多数Three.js内置的着色器中，这些坐标都会自动添加到每个顶点的纹理UV坐标中。


### 中级
3D模型的定义：3D模型由定点组成，顶点之间连成三角形和四边形，并最终由无数个多边形构成的复杂的立体模型。
轻量级查看3d模型：Blender、ParaView
模型的加载思路：
1.服务器上的模型文件多存储模型的顶点信息，信息以文本方式存储。
2.浏览器加载文件，异步也可以实现。
3.javascript解析文本并生产一个geometry，最终生产mesh模型。

当你年轻时，投资教育是最合算的。进入社会后，你就没有那么多时间来投资教育了。

开启阴影渲染：
如果光源和目标点之间的连线没有任何物体阻挡的话，则目标点没有在阴影中；如果物体遮挡，则目标点处在阴影中。而ShadowMap，就是一张记录了每个像素处于比较遮挡关系信息的Texture。
shadowMapSoft等于true，可以是阴影更加平滑，产生更少的锯齿。

浏览器窗口的左上角坐标为(0,0),右下角就是浏览器的宽度和高度，单位是像素。
视口的坐标为归一化坐标，也就是说左上角是(0,0),右下角是（1,1）。
后续：取得鼠标的位置，并且将其转换为-1到1之间，就是归一化。

三维空间中的点变为二维屏幕上的点是通过投影运算得到的，所以二维空间变到三维空间是通过反投影运算得到。

二维和三维转的关键是Three.projector类，此类中有一个unprojectVector函数，这个函数是将归一化空间中的点，就是最后将（-1，-1，-1）到（1,1,1）中的某个点还原成三维空间中的某个点。

怎么样知道鼠标是否在三维空间中选中了什么物体或者没有选中物体？
从相机到鼠标（已经转为三维空间中）发射的一条射线，与射线相交的点，就是选中的物体的某一个点。

Three.ShaderLib是three.js引擎的一个数组，数组中的cube哪一项存放的是立方体贴图的shader，shader是直接操作显卡的一段程序。Shader可以理解为能够直接操作显卡硬件的汇编语言，webgl原声api可以理解为比汇编语言高级一点的c语言。

setFaceCulling函数是是否裁剪的意思。

new THREE.MeshLambertMaterial({color:0xff6600,ambient:0xff2200,envMap:textureCube,combine:THREE。miaOperation,reflectivity:0.3}),
color:材质的颜色
envMap：材质的环境纹理，就是会将环境纹理映射到自己身上。
combine：表示本来的材质和环境材质之间的混合方式。
reflectivity:表示材质对反射光的反射系数。

天空盒
天空盒在游戏中使用很多，一般天空盒的实现有两种，一种是立方体内部贴纹理来实现，一种是椭圆球体内部贴纹理实现。
loadTextureCube（urls）
controls= new THREE.FirstPersonControls(camera);  //第一人称相机
controls.movementSpend=20;
controls.lookSpeed=0.05;
controls.lookVertical=true;
movementSpeed属性表示移动的速度，相机前后左右的移动速度。
lookSpeed 上下左右转头的速度
lookVertical属性表示允许抬头或者低头，false的时候，上下键都是无效的。


将多个geometry合并为一个geometry，上面的操作就能一次完成了。函数是Three.GeometryUtils.merge
去掉物质的材质  geometry.faceVertexUvs[0][2][0].set(0,0);


中级复习
geometry.computeCentroids()计算geometry中每一个面的重心，重心可以求坐标的平均值来得到。重心被存储在face.centroid这个变量中。
geometry.computeFaceNormals()计算每一个面归一后的法向量，法向量垂直于面，计算之后的法向量被存放在了face.normal中。

geometry.computeVertexNormals()计算一个顶点的法向量。

geometry.computeBoundingSphere() 计算一个可以包围geometry的一个椭圆，中心点就是geometry的中点，sphere的最大半径是离中心点最远的那一个点。

三角形是构成实体的基本单位，因为一个三角形正好是一个平面，以三角形面为单位进行渲染效率最高。通常说的的顶点，是所有三角形的三个三个顶点。顶点按顺时针排列的表面是正面。
其中与三角形平面垂直、且指向正面的矢量称为平面的法线。顶点法线是过顶点的一个矢量，用于在高洛德着色中的计算光照和纹理效果。生成曲面时，通常令顶点法线和相邻平面的法线保持等角，进行渲染时，会在平面接缝处产生一种平滑过渡的效果。如果是多边形，则令顶点法线等于该点所属平面的法线，以便在接缝处产生突出的边缘。
总结，如果将顶点的法线和面的法线设置为一样，则边线因为受光照强，所以就明显一些。注意，法线与入射角的角度越小，则该点光线越强。

THREE.EffectComposer，效果组合器，就是将各种效果放在一个数组里面，待渲染的时候，统一渲染。渲染完成后，就能够得到最终的效果。
var  shadowTexture=new THREE.Texture('canvas');
shadowTexture.needsUpdate=true;
needsUpdate设置为true表示纹理是新纹理，在绘制的时候，需要更新到材质上。

渐变色的形成：显示在面上的颜色都是渐变色，这种渐变色是将三个面的每一个顶点赋予不同的颜色值形成的。